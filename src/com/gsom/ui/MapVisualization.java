/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.gsom.ui;

import com.gsom.enums.MapPlotType;
import com.gsom.objects.GCluster;
import com.gsom.objects.GNode;
import com.gsom.ui.utils.ColorIcon;
import com.gsom.util.GSOMConstants;
import com.gsom.util.Utils;
import java.awt.*;
import java.awt.color.ColorSpace;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import javax.swing.*;

/**
 *
 * @author Thushan Ganegedara
 */
public class MapVisualization extends javax.swing.JFrame {

    /**
     * Creates new form MapVisualization
     */
    public MapVisualization() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        nodeInfoTxt = new javax.swing.JTextArea();
        mapScrollPane = new javax.swing.JScrollPane();
        containerBtnPanel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("GSOM Visualization");

        nodeInfoTxt.setColumns(20);
        nodeInfoTxt.setRows(5);
        jScrollPane1.setViewportView(nodeInfoTxt);

        javax.swing.GroupLayout containerBtnPanelLayout = new javax.swing.GroupLayout(containerBtnPanel);
        containerBtnPanel.setLayout(containerBtnPanelLayout);
        containerBtnPanelLayout.setHorizontalGroup(
            containerBtnPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 468, Short.MAX_VALUE)
        );
        containerBtnPanelLayout.setVerticalGroup(
            containerBtnPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 401, Short.MAX_VALUE)
        );

        mapScrollPane.setViewportView(containerBtnPanel);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(mapScrollPane)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 361, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addComponent(mapScrollPane))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    private Map<String, GNode> map;
    private Map<String, String> testResults;
    private ArrayList<GCluster> clusters;

    public void setData(Map<String, GNode> map, Map<String, String> testResults, ArrayList<GCluster> clusters, ArrayList<String> bestHist, MapPlotType mType) {
        this.map = map;
        this.testResults = testResults;
        this.clusters = clusters;

        if (mType != MapPlotType.BEST_HIT) {
            displayGSOM(map, testResults, clusters, mType);
        } else {
            displayBestHits(map, testResults, bestHist);
        }
    }

    private ArrayList<Color> getClusterColors(int k) {
        ArrayList<Color> colors = new ArrayList<Color>();
        
        if(k<=5){
            for(int i=0;i<k;i++){
                Color color = Color.getHSBColor((60.0f*i)/360, 0.8f, 0.5f);
                colors.add(color);
            }
        }
        else{
            for(int i=0;i<5;i++){
                Color color = Color.getHSBColor((60.0f*i)/360, 0.8f, 0.5f);
                colors.add(color);
            }
            for(int i=0;i<5;i++){
                Color color = Color.getHSBColor((60.0f*i)/360, 0.8f, 0.7f);
                colors.add(color);
            }
            for(int i=0;i<5;i++){
                Color color = Color.getHSBColor((60.0f*i)/360, 0.8f, 0.35f);
                colors.add(color);
            }
            for(int i=0;i<5;i++){
                Color color = Color.getHSBColor((60.0f*i)/360, 0.8f, 0.6f);
                colors.add(color);
            }
        }
        
        

        return colors;
    }

    private void displayBestHits(Map<String, GNode> map, Map<String, String> testResults, ArrayList<String> bestHits) {

        int[] minMax = getMaxMinFromMap(map);

        //create a network of buttons wit given width & height to represent nodes in the GSOM
        int btnWidth = 50;
        int btnHeight = 50;
        int iconWidth = 15;
        int iconHeight = 15;

        int frameWidth = (minMax[2] - minMax[0] + 1) * btnWidth;
        int frameHeight = (minMax[3] - minMax[1] + 1) * btnHeight;


        JPanel btnPanel = new JPanel();
        btnPanel.setPreferredSize(new Dimension(frameWidth, frameHeight));
        btnPanel.setLayout(new GridLayout(minMax[2] - minMax[0] + 1, minMax[3] - minMax[1] + 1));

        for (int x = 0; x <= minMax[2] - minMax[0]; x++) {
            for (int y = 0; y <= minMax[3] - minMax[1]; y++) {
                final String loc = Utils.generateIndexString(x, y);

                if (map.containsKey(loc)) {

                    String nodeLoc = "Location: " + loc;
                    String nodeWeights = "Node Wegihts: ";
                    for (int i = 0; i < map.get(loc).getWeights().length; i++) {
                        DecimalFormat df = new DecimalFormat("#.000");
                        nodeWeights += df.format(map.get(loc).getWeights()[i]) + ", ";
                    }


                    String nodeHitValue = "Hit Value: " + map.get(loc).getHitValue();
                    String nodeErrValue = "Error Value: " + map.get(loc).getErrorValue();
                    String nodeHits = "Hits: ";

                    JButton btn = new JButton();
                    btn.setPreferredSize(new Dimension(btnWidth, btnHeight));

                    if (bestHits.contains(loc)) {
                        nodeHits += testResults.get(loc);
                        btn.setFont(new Font("Arial", Font.PLAIN, 9));
                        //btn.setIcon(new ColorIcon(iconWidth, iconHeight, Color.black));
                        btn.setText(bestHits.indexOf(loc)+"");
                    }

                    final String fullStr = nodeLoc + "\n" + nodeWeights + "\n" + nodeErrValue + "\n" + nodeHitValue + "\n" + nodeHits;
                    btn.addActionListener(new ActionListener() {

                        @Override
                        public void actionPerformed(ActionEvent ae) {
                            nodeInfoTxt.setLineWrap(true);
                            nodeInfoTxt.setText(fullStr);
                        }
                    });
                    btnPanel.add(btn);
                } else {
                    JLabel lbl = new JLabel();
                    lbl.setSize(btnWidth, btnHeight);
                    btnPanel.add(lbl);
                }
            }
        }

        btnPanel.setBounds(0, 0, frameHeight, frameWidth);
        containerBtnPanel.add(btnPanel);
        containerBtnPanel.setMinimumSize(new Dimension(frameWidth, frameHeight));
        containerBtnPanel.setPreferredSize(new Dimension(frameWidth, frameHeight));
        //mapScrollPane.setBounds(0, 0, frameWidth, frameHeight);
        mapScrollPane.setViewportView(containerBtnPanel);
    }

    private void displayGSOM(Map<String, GNode> map, final Map<String, String> testResults, ArrayList<GCluster> clusters, MapPlotType mType) {

        
        Map<String, String> nodeInfo = new HashMap<String, String>();
        /*
         * Image image = null; try { image = ImageIO.read(new
         * File("images\\green_icon.jpg")); } catch (IOException ex) {
         * Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null,
         * ex); }
         */
        //find min x, min y & max x, max y
        int[] minMax = getMaxMinFromMap(map);

        //create a network of buttons wit given width & height to represent nodes in the GSOM
        int widthFreeSpace = 50;
        int heightFreeSpace = 50;
        int btnWidth = 25;
        int btnHeight = 25;
        int iconWidth = 15;
        int iconHeight = 15;

        int frameWidth = (minMax[2] - minMax[0] + 1) * btnWidth;
        int frameHeight = (minMax[3] - minMax[1] + 1) * btnHeight;


        JPanel btnPanel = new JPanel();
        btnPanel.setPreferredSize(new Dimension(frameWidth, frameHeight));
        btnPanel.setLayout(new GridLayout(minMax[2] - minMax[0] + 1, minMax[3] - minMax[1] + 1));

        for (int x = 0; x <= minMax[2] - minMax[0]; x++) {
            for (int y = 0; y <= minMax[3] - minMax[1]; y++) {
                final String loc = Utils.generateIndexString(x, y);
                String rLoc = Utils.generateIndexString(x + 1, y);
                String lLoc = Utils.generateIndexString(x - 1, y);
                String uLoc = Utils.generateIndexString(x, y + 1);
                String dLoc = Utils.generateIndexString(x, y - 1);

                if (map.containsKey(loc)) {

                    String nodeLoc = "Location: " + loc;
                    String nodeWeights = "Node Wegihts: ";
                    for (int i = 0; i < map.get(loc).getWeights().length; i++) {
                        DecimalFormat df = new DecimalFormat("#.000");
                        nodeWeights += df.format(map.get(loc).getWeights()[i]) + ", ";
                    }


                    String nodeHitValue = "Hit Value: " + map.get(loc).getHitValue();
                    String nodeErrValue = "Error Value: " + map.get(loc).getErrorValue();
                    String nodeHits = "Hits: ";
                    String clusterID = "Cluster ID: ";
                    String clusterLoc = "Cluster Centroid: ";
                    String clusterWeight = "Cluster Centroid Weight: ";

                    JButton btn = new JButton();
                    btn.setPreferredSize(new Dimension(btnWidth, btnHeight));

                    if (testResults.containsKey(loc)) {
                        nodeHits += testResults.get(loc);

                        if (mType == MapPlotType.CLUSTERS) {
                            ArrayList<Color> colors = getClusterColors(clusters.size());
                            int cIdx = 0;
                            for (int i = 0; i < clusters.size(); i++) {
                                for (int j = 0; j < clusters.get(i).getcNodes().size(); j++) {
                                    GNode gn = clusters.get(i).getcNodes().get(j);
                                    if (Utils.generateIndexString(gn.getX(), gn.getY()).equals(loc)) {
                                        cIdx = i;
                                        break;
                                    }
                                }
                            }
                            clusterID += cIdx + "";
                            clusterLoc += Utils.generateIndexString(clusters.get(cIdx).getX(), clusters.get(cIdx).getY());
                            for (double v : clusters.get(cIdx).getCentroidWeights()) {
                                DecimalFormat df = new DecimalFormat("#.000");
                                clusterWeight += df.format(v) + ",";
                            }
                            //btn.setForeground(colors.get(cIdx));
                            btn.setIcon(new ColorIcon(iconWidth, iconHeight, colors.get(cIdx)));
                        }

                    }else{
                        if (mType == MapPlotType.CLUSTERS) {
                            ArrayList<Color> colors = getClusterColors(clusters.size());
                            int cIdx = 0;
                            for (int i = 0; i < clusters.size(); i++) {
                                for (int j = 0; j < clusters.get(i).getcNodes().size(); j++) {
                                    GNode gn = clusters.get(i).getcNodes().get(j);
                                    if (Utils.generateIndexString(gn.getX(), gn.getY()).equals(loc)) {
                                        cIdx = i;
                                        break;
                                    }
                                }
                            }
                            
                            //btn.setForeground(colors.get(cIdx));
                            btn.setIcon(new ColorIcon((3*iconWidth)/4, (3*iconHeight)/4, colors.get(cIdx)));
                        }
                    }

                    if (mType == MapPlotType.HEAT_MAP) {
                        double[] rWeight = null;
                        double[] lWeight = null;
                        double[] uWeight = null;
                        double[] dWeight = null;

                        if (map.get(rLoc) != null) {
                            rWeight = map.get(rLoc).getWeights();
                        }
                        if (map.get(lLoc) != null) {
                            lWeight = map.get(lLoc).getWeights();
                        }
                        if (map.get(uLoc) != null) {
                            uWeight = map.get(uLoc).getWeights();
                        }
                        if (map.get(dLoc) != null) {
                            dWeight = map.get(dLoc).getWeights();
                        }

                        Color btnColor = getHeatColor(map.get(loc).getWeights(), rWeight, lWeight, uWeight, dWeight);
                        btn.setIcon(new ColorIcon(iconWidth, iconHeight, btnColor));
                    }

                    final String fullStr = nodeLoc + "\n" + nodeWeights + "\n" + nodeErrValue + "\n" + nodeHitValue + "\n" + nodeHits
                            + "\n\n" + clusterID + "\n" + clusterLoc + "\n" + clusterWeight;
                    btn.addActionListener(new ActionListener() {

                        @Override
                        public void actionPerformed(ActionEvent ae) {
                            nodeInfoTxt.setLineWrap(true);
                            nodeInfoTxt.setText(fullStr);
                        }
                    });
                    btnPanel.add(btn);

                } else {
                    JLabel lbl = new JLabel();
                    lbl.setSize(btnWidth, btnHeight);
                    btnPanel.add(lbl);
                }
            }
        }

        btnPanel.setBounds(0, 0, frameHeight,frameWidth);
        containerBtnPanel.add(btnPanel);
        containerBtnPanel.setMinimumSize(new Dimension(frameWidth, frameHeight));
        containerBtnPanel.setPreferredSize(new Dimension(frameWidth, frameHeight));
        //mapScrollPane.setBounds(0, 0, frameWidth, frameHeight);
        mapScrollPane.setViewportView(containerBtnPanel);
    }

    private Color getHeatColor(double[] weight, double[] rWeight, double[] lWeight, double[] uWeight, double[] dWeight) {
        ArrayList<double[]> neigh = new ArrayList<double[]>();
        neigh.add(rWeight);
        neigh.add(lWeight);
        neigh.add(uWeight);
        neigh.add(dWeight);

        int count = 0;
        double dist = 0.0;
        for (double[] arr : neigh) {
            if (arr != null) {
                dist = +Utils.calcEucDist(weight, arr, GSOMConstants.DIMENSIONS);
                count++;
            }
        }

        double maxDist = Math.sqrt(GSOMConstants.DIMENSIONS) / 4;

        int rgbVal = (int) ((dist) * 255 / (count * maxDist));
        if (rgbVal > 255) {
            rgbVal = 255;
        }
        //rgbVal = 255-rgbVal;
        return new Color(rgbVal, rgbVal, rgbVal);
    }

    private int[] getMaxMinFromMap(Map<String, GNode> map) {
        ArrayList<Integer> xVal = new ArrayList<Integer>();
        ArrayList<Integer> yVal = new ArrayList<Integer>();

        for (GNode g : map.values()) {
            xVal.add(g.getX());
            yVal.add(g.getY());
        }

        int[] minMax = new int[4];
        minMax[0] = Collections.min(xVal);
        minMax[1] = Collections.min(yVal);
        minMax[2] = Collections.max(xVal);
        minMax[3] = Collections.max(yVal);

        return minMax;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /*
         * Set the Nimbus look and feel
         */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /*
         * If Nimbus (introduced in Java SE 6) is not available, stay with the
         * default look and feel. For details see
         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;


                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MapVisualization.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MapVisualization.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MapVisualization.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MapVisualization.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /*
         * Create and display the form
         */
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new MapVisualization().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel containerBtnPanel;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane mapScrollPane;
    private javax.swing.JTextArea nodeInfoTxt;
    // End of variables declaration//GEN-END:variables
}
